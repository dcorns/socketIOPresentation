<!-- views/index.html -->
<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Socket.IO Exposed</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="stylesheet" href="components/reveal.js/css/reveal.min.css">
    <link rel="stylesheet" href="components/reveal.js/css/theme/default.css" id="theme">

</head>
<body>
<div class="reveal">
    <div class="slides">

        <section>
            <h1>SOCKET.IO</h1>
            <ul>
                <li>Login into the website</li>
                <li>Who has heard of socket.io</li>
                <li>Who has used socket.io</li>
                <li>Examples site</li>
            </ul>
        </section>
        <section>
            <h1>What is socket.io?</h1>
            <p class="fragment roll-in">"Socket.io enables real-time bidirectional event-based communications."</p>
            <p class="fragment fade-in">"It works on every platform, browser or device, focusing equally on reliability and speed"</p>
            <p class="fragment roll-in">"my definition"</p>
            <p class="fragment fade-in">"Websocket is a bi-directional and assynchronus communications protocol that does so without the need for opening multiple HTTP connections (e.g., using
                XMLHttpRequest or iframes and long polling)."</p>

        </section>

        <section>
            <h1 >Before Websocket</h1>
            <span class="fragment fade-in">
            <span class="fragment fade-out">XMLHttpRequest: "XMLHttpRequest is a JavaScript object that was designed by Microsoft and adopted by Mozilla, Apple, and Google. It's now being standardized in the W3C. It provides an easy way to retrieve data from a URL without having to do a full page refresh. XMLHttpRequest is used heavily in AJAX The complexity of XMLHttpRequest is why we have Ajax. Learn all about XML... at link</span>
            </span>
            <span class="fragment roll-in">
            <span class="fragment fade-out">
                Using Iframes is actually a hack that came before XMHttpRequest, you can read about what iframes are actually for at the link.
            </span></span>
            <span class="fragment roll-in"><span class="fragment fade-out">
            Long polling is implemented by using a recursive ajax request. For a decent overview of polling see link.
        </span></span>
        </section>
        <section>
            long polling example
        </section>
        <section>
            <h1>The Websocket Way</h1>
            <h3><a class="fragment fade-in" href="http://tools.ietf.org/html/rfc6455">RFC6455</a></h3>
            <p class="fragment roll-in">HTTP Handshake HTTP Upgrade Header added in spec 1.1 It allows the client to specify additional protocols</p>
            <p class="fragment roll-in">Frames Once the handshake is over websocket takes over allowing for true bi-directional communication using tcp frames. Client or server can send a frame at anytime, can be shared over same port as http, but does not have to be</p>
        </section>
        <section>
            <h1>Engine.IO</h1>
            <h3 class="fragment roll-in">Engine.io "the implementation of transport-based cross-browser/cross-device bi-directional communication layer for Socket.IO"
                Determines the best transport for given device or browser, fallback if no websocket
                can be removed from v1.0 plus</h3>
        </section>
        <section>
            <h1>Version 1.0x vrs 0.9</h1>
            <p class="fragment roll-in">Stability many issues if you watch the repository, lots of emails</p>
            <p class="fragment roll-in">io.use() You can give a Socket.io server arbitrary functions via io.use() that are run when a socket is created.</p>
            <p class="fragment roll-in">engine.IO -If WebSocket is the only transport you want to support moving forward, Engine.IO (with all its browser hacks and workarounds) can be seamlessly removed.</p>
            <p class="fragment roll-in">Binary support -  Socket.IO now supports emitting Buffer (from Node.JS), Blob, ArrayBuffer and even File, as part of any datastructure</p>
            <p class="fragment roll-in">automated testing- Every commit to the Socket.IO codebase now triggers a testing matrix totaling to 25 browsers, including Android and iOS. </p>
        </section>
        <section>
            <h1>Version 1.0 vrs 0.9</h1>
            <p class="fragment roll-in">Scalability- Instead of storing and/or replicating data across nodes, Socket.IO is now only concerned with passing events around. We have deprecated the Socket#set and Socket#get APIs. Packets now simply get encoded and distributed to other nodes whenever you broadcast, and we don’t deal with storage.</p>
            <p class="fragment roll-in">Integration -the socket.io-emitter project which hooks into socket.io-redis to easily allow you to emit events to browsers from anywhere: var io = require('socket.io-emitter')();setInterval(function(){io.emit('time', new Date);}, 5000);</p>
            <p class="fragment roll-in">Debugging -Socket.IO is now completely instrumented in debug by TJ Holowaychuk.In the past, the Socket.IO server would default to logging everything out to the console. Now suppressed but you can opt into seeing messages by supplying the DEBUG env variable (Node.JS) or the localStorage.debug property (Browsers). Or verbose it by DEBUG=* node app</p>
            <p class="fragment roll-in">CDN Delivery -(thanks to Google’s zopfli and proper support for caching, you can now use our CDN. It’s free, forever, and has built-in SSL support:     script src="https://cdn.socket.io/socket.io-1.0.0.js">/script></p>
            <p class="fragment roll-in">Socket.IO v1.0 -endepth information on V1.0 and the vision of socket.io</p>

        </section>
        <section>
            <h1>So Again what is socket.io really?</h1>
            <p class="fragment roll-in">Sugar</p>
            <p class="fragment roll-in">Abstraction</p>
            <p class="fragment roll-in">Complexity</p>
            <p class="fragment roll-in">Less Code</p>
        </section>
        <section >
            <h4 class="fragment fade-in">A simple means of implementing the websocket IP protocol over TCP for true bidirectional, asynchronus communications between client and server with a little extra sugar</h4>
        </section>
        <section>
            <h1>So for what is it good?</h1>
            <h3 class="fragment roll-in">Anything Realtime!</h3>
            <h3 class="fragment roll-in">Client or Server - once established, communications can be initiated from either end</h3>
        </section>
        <section>
            <h1>Examples</h1>
            <h4><a href="https://github.com/dcorns/exploreSocketIO">clone exploreSocketIO</a></h4>
            <p>nodeOnly</p>
            <p>nodeExpress</p>
            <p>areYouDeaf -using events on the server and client side to communicate server side rendering</p>
            <p>shutupAlready -using events to stretch functions across endpoints</p>
            <p>realtimeUpdate -demonstrates realtime interaction between clients of the server</p>
            <p>nameSpace -using name spacing to separate communications</p>
            <p>bievents - using builtin events</p>
        </section>
        <section>
            <h1>Server Setup</h1>
            <h3 class="fragment roll-in">var app = require('express')();</h3>
            <h3 class="fragment roll-in">var server = require('http').Server(app);</h3>
            <h3 class="fragment roll-in">var io = require('socket.io')(server);</h3>
            <h3 class="fragment roll-in">server.listen(<i>port</i>)</h3>
            <h3 class="fragment roll-in">app.get('/', function(req, res{</br>res.sendfile(__dirname + '<i>html</i>')});</h3>
        </section>
        <section>
            <h1>Client Setup</h1>
            <h3 class="fragment roll-in">script src="/socket.io/socket.io.js"</h3>
            <h3 class="fragment roll-in">script src="https://cdn.socket.io/socket.io-1.0.0.js"</h3>
            <h3 class="fragment roll-in">var socket = io(); Here is the client</h3>
            <h3 class="fragment roll-in">var socket = io(<i>url</i>)</h3>
        </section>
        <section>
            <p>Connection Proccess -excluding transport negotiation as most browsers now support web sockets</p>
            <h3 class="fragment roll-in">Client sends GET request </h3>
            <h3 class="fragment roll-in">Server sends script</h3>
            <h3 class="fragment roll-in">Handshake</h3>
            <h3 class="fragment roll-in">Websocket Open</h3>
        </section>
        <section>
            <h1>Events</h1>
            <p>error -on an error parameter {error data}</p>
            <p>connect -on client connect, fires</p>
            <p>connection -server side after connected</p>
            <p>message -not sure but need to use it so chat works correctly</p>
            <p>disconnected - others not discussed 'open''close''retry''reconnect'</p>
            <p>Custom Events</p>
        </section>
        <section>
            <h1>Events Listener/Handler</h1>
            <h3>on</h3>
            <h4>socket.on('<i>eventname</i>',function(){</br>
                });
            </h4>
        </section>
        <section>
            <h1>Custom Events</h1>
            <h3>emit</h3>
            <h4>socket.emit('<i>eventname</i>',{});
            </h4>
            <h4>socket.broadcast.emit('eventname',{});</h4>
        </section>
        <section>
            <h1>NameSpacing</h1>
            <h3>Default /</h3>
            <h3>Custom Namespacing</h3>
        </section>
        <section>
            <h1>Lab: Chat Room</h1>
            <a class="fragment fade-in" href="https://github.com/dcorns/socketIOPresentaion">This presentation was done using express, reveal and socket.io</a>
            <a class="fragment roll-in" href="hrrps://github.com/dcorns/simplechat">Working Chat Example</a>
        </section>
    </div>
</div>
<script src="components/reveal.js/js/reveal.min.js"></script>
<script type="text/javascript">
    Reveal.initialize({history: true});
</script>
<script src="/socket.io/socket.io.js"></script>
<script type="text/javascript">src=(function(){
    var host = 'http://localhost:3000',
            socket = io.connect(host);
    Reveal.initialize({
        history: true
    });

    /** start - only in master.js **/
    notifyServer = function(event){
        data = {
            indexv : Reveal.getIndices().v,
            indexh : Reveal.getIndices().h,
            indexf : Reveal.getIndices().f || 0
        }
        socket.emit("slidechanged" , data);
    }
    // listeners for slide change/ fragment change events
    Reveal.addEventListener("slidechanged", notifyServer);
    Reveal.addEventListener("fragmentshown", notifyServer);
    Reveal.addEventListener("fragmenthidden", notifyServer);
    /** end - only in master.js **/

        // Move to corresponding slide/ frament on receiving
        // slidechanged event from server
    socket.on('slidechanged', function (data) {
        Reveal.slide(data.indexh, data.indexv, data.indexf);
        console.log(data);
        socket.emit('my other event',{my:'data'});
    });

})();</script>
<script src="js/slidedata.js"></script>
<script src="js/slideActions.js"></script>
</body>
</html>